outside says ?pk:text ?pa:number ?pz:number has child ?ck:text ?ca:number ?cz:number with text ?c:text
=

?parent:text contains ?child:text found by capture ?n:number of ?regex:text
=
"program" "view" 0 "(.+\n?)+"
"view" "head" 0 "^.*"
"view" "insert" 1 "\n\+((\n[^\+-=].*)+)"
"view" "remove" 1 "\n-((\n[^\+-=].*)+)"
"view" "input" 1 "\n=(.*(\n[^\+-=].*)+)"
"head" "variable with kind" 2 "(^|\s)(\?[:alnum:]*:[:alnum:]*)"
"variable with kind" "kind" 1 ":([:alnum:]*)"
"variable with kind" "variable" 1 "\?([:alnum:]*)"
"insert" "clause" 1 "\n(.*)"
"remove" "clause" 1 "\n(.*)"
"clause" "negation" 0 "^! "
"clause" "clause body" 2 "^(! )?(.*)"
"clause body" "binding" 2 "(^|\s)(_\S*|\?[:alnum:]*|#[:digit:]+|-?[:digit:]+(\.[:digit]+)?|\x22(\\\x22|[^\x22])*\x22)"
"binding" "unbound" 0 "^_\S*$"
"binding" "variable" 1 "^\?([:alnum:]*)$"
"binding" "id" 0 "^#[:digit:]+$"
"binding" "number" 0 "^-?[:digit:]+(\.[:digit]+)?$"
"binding" "text" 0 "^\x22(\\\x22|[^\x22])*\x22$"
"clause body" "grouping" 1 " over (.*)"
"input" "import" 0 "^.*"
"import" "filename" 1 "^\s*(\S*)"
"import" "cols" 1 "^\s*\S*(.*)"
"cols" "col" 1 "\s*(\S*)"
"input" "row" 1 "\n(.*)"
"row" "value" 2 "(^|\s)(#[:digit:]+|-?[:digit:]+(\.[:digit]+)?|\x22(\\\x22|[^\x22])*\x22)"
"value" "id" 0 "#[:digit:]+"
"value" "number" 0 "-?[:digit:]+(\.[:digit]+)?"
"value" "text" 0 "\x22(\\\x22|[^\x22])*\x22"

child ?ck:text ?ca:number ?cz:number of ?pk:text ?pa:number ?pz:number has text ?c:text
+
outside says ?pk ?pa ?pz has child ?ck ?ca ?cz with text ?c
+
?pk contains ?ck found by capture ?n of ?re
child ?pk ?pa ?pz of _ _ _ has text ?p
capture ?n of result _ of ?p searched by ?re is at ?ra to ?rz
?ca = ?pa + ?ra
?cz = ?pa + ?rz
the text at ?ra to ?rz in ?p is ?c

head ?va:number ?vz:number is named ?n:text
+
child "head" ?va ?vz of _ _ _ has text ?v
"head" contains "variable with kind" found by capture _ of ?re
?v with ?re replaced by "$1_" is ?n

clause ?va:number ?vz:number is named ?n:text
+
child "clause body" _ _ of "clause" ?va ?vz has text ?v
"clause body" contains "binding" found by capture _ of ?re
"clause body" contains "grouping" found by capture _ of ?re2
?v with ?re replaced by "$1_" is ?n2
?n2 with ?re2 replaced by "" is ?n

?k:text becomes a node of type ?t:text
=
"view" "union"
"input" "input"
"insert" "query"
"remove" "query"

node ?n:number of type ?t:text is at ?na:number ?nz:number
+
?k becomes a node of type ?t
child ?k ?na ?nz of _ _ _ has text _
row ?n over ?nz ?na ?k ?t

node ?n1:number depends on node ?n2:number
+
node ?n1 of type "union" is at ?na ?nz
child _ ?ca ?cz of "view" ?na ?nz has text _
node ?n2 of type _ is at ?ca ?cz
+
node ?n1 of type "query" is at ?na ?nz
child "clause" ?ca ?cz of _ ?na ?nz has text _
clause ?ca ?cz is named ?name
head ?ha ?hz is named ?name
child "head" ?ha ?hz of "view" ?va ?vz has text _
node ?n2 of type "union" is at ?va ?vz

field ?f:number of node ?n:number has variable ?v:text and kind ?k:text
+
node ?n of type "union" is at ?na ?nz
child "head" ?ha ?hz of "view" ?na ?nz has text _
child "variable with kind" ?vka ?vkz of "head" ?ha ?hz has text _
child "variable" _ _ of "variable with kind" ?vka ?vkz has text ?v
child "kind" _ _ of "variable with kind" ?vka ?vkz has text ?k
row ?f over ?vka ?vkz ?v ?k
+
field ?f of node ?n2 has variable ?v and kind ?k
node ?n2 of type "union" is at _ _
node ?n2 depends on node ?n

values of kind ?k:text have width ?w:number
=
"id" 1
"number" 1
"text" 2

member ?m:number of union node ?n:number is ?action:text node ?n2:number
+
node ?n of type "union" is at ?na ?nz
child ?action ?ca ?cz of "view" ?na ?nz has text _
node ?n2 of type "query" is at ?ca ?cz
row ?m over ?ca ?cz ?n2 ?action

union node ?n:number has key ?f:number = ?v:number
+
field ?f of node ?n has variable _ and kind ?k
field ?f2 of node ?n has variable _ and kind ?k2
?f2 < ?f
values of kind ?k2 have width ?w
?v = sum(?w) over ?f2 ?k2

row at ?ra:number ?rz:number is row ?r:number
+
child "row" ?ra ?rz of "input" ?na ?nz has text _
row ?r over ?ra ?rz

value at ?va:number ?vz:number is value ?v:number
+
child "value" ?va ?vz of "row" ?ra ?rz has text _
row ?v over ?va ?vz

field ?f:number of row ?r:number of input node ?n:number has raw value ?v:text
+
node ?n of type "input" is at ?na ?nz
child "row" ?ra ?rz of "input" ?na ?nz has text _
child "value" ?va ?vz of "row" ?ra ?rz has text ?v
row at ?ra ?rz is row ?r
value at ?va ?vz is value ?f

field ?f:number of row ?r:number of input node ?n:number has id value ?v:number
+
field ?f of node ?n has variable _ and kind "id"
field ?f of row ?r of input node ?n has raw value ?raw
?raw is id ?v

field ?f:number of row ?r:number of input node ?n:number has number value ?v:number
+
field ?f of node ?n has variable _ and kind "number"
field ?f of row ?r of input node ?n has raw value ?raw
?raw is number ?v

field ?f:number of row ?r:number of input node ?n:number has text value ?v:text
+
field ?f of node ?n has variable _ and kind "text"
field ?f of row ?r of input node ?n has raw value ?v

clause ?c:number of node ?n:number is at ?ca:number ?cz:number
+
node ?n of type _ is at ?na ?nz
child "clause" ?ca ?cz of _ ?na ?nz has text _
row ?c over ?ca ?cz

clause ?c:number of node ?n:number binds ?v:text
+
clause ?c of node ?n is at ?ca ?cz
child "clause body" ?cba ?cbz of "clause" ?ca ?cz has text _
child "binding" ?ba ?bz of "clause body" ?cba ?cbz has text _
child "variable" ?va ?vz of "binding" ?ba ?bz has text ?v

view ?n:text is primitive
=
"_ = _ + _"
"_ = sum(_)"
"row _"
"_ < _"
"_ <- _"
"_ <<- _"
"min"
"result _ of _ split by _ is at _ to _ breaking at _"
"result _ of _ searched by _ is at _ to _"
"capture _ of result _ of _ searched by _ is at _ to _"
"_ with _ replaced by _ is _"
"the text at _ to _ in _ is _"
"_ has length _"
"_ is number _"
"_ is id _"
"_ != _"
"count _"
"_ = get bit _ of _"
"_ = set bit _ of _"

clause ?c:number of node ?n:number is primitive
+
clause ?c of node ?n is at ?ca ?cz
clause ?ca ?cz is named ?name
view ?name is primitive

clause ?c:number of node ?n:number is negated
+
clause ?c of node ?n is at ?ca ?cz
child "negation" _ _ of "clause" ?ca ?cz has text _

clause ?c:number of node ?n:number is finite
+
clause ?c of node ?n is at ?ca ?cz
! clause ?c of node ?n is primitive
! clause ?c of node ?n is negated

clause ?c:number of node ?n:number is unjoined in step ?s:number
+
clause ?c of node ?n is finite
?s <- 0
+
clause ?c of node ?n is unjoined in step ?s2
?s = ?s2 + 1
clause ?o of node ?n is joined to clause _ in step ?s2
?c != ?o

clause ?c:number of node ?n:number is joined to clause ?p:number in step ?s:number
+
clause ?c of node ?n is unjoined in step ?s
clause ?p of node ?n is unjoined in step ?s
?c != ?p
! clause ?c of node ?n is not covered by clause ?p in step ?s
row 0 over ?c ?p

clause ?c:number of node ?n:number is not covered by clause ?p:number in step ?s:number
+
clause ?c of node ?n binds ?v
! clause ?p of node ?n binds ?v
clause ?o of node ?n binds ?v
?c != ?o
clause ?p of node ?n is unjoined in step ?s
clause ?o of node ?n is unjoined in step ?s

node ?n:number has root clause ?c:number
+
clause ?c of node ?n is unjoined in step 0
count 1 over ?c
+
clause _ of node ?n is joined to clause ?c in step ?s
min over -?s ?c

clause ?c:number is not joined in node ?n:number
+
clause ?c of node ?n is unjoined in step 0
! clause ?c of node ?n is joined to clause _ in step _
! node ?n has root clause ?c

node ?n:number is named ?name:text
+
node ?n of type _ is at ?na ?nz
child "head" ?ha ?hz of _ ?na ?nz has text _
head ?ha ?hz is named ?name

node ?n:number has subtree ?t:id
+
clause ?c of node ?n is unjoined in step 0
?t = set bit ?c of #0
+
clause ?c of node ?n is joined to clause ?p in step _
node ?n has subtree ?t2
1 = get bit ?p of ?t2
?t = set bit ?c of ?t2

node ?n:number subtree ?t:id binds ?v:text
+
node ?n has subtree ?t
clause ?c of node ?n is unjoined in step 0
1 = get bit ?c of ?t
clause ?c of node ?n binds ?v

node ?n:number subtree ?t:id does not finish ?v:text
+
node ?n has subtree ?t
clause ?c of node ?n is unjoined in step 0
0 = get bit ?c of ?t
clause ?c of node ?n binds ?v

primitive ?p:text field ?f:number is a ?kind:text ?type:text
=
"_ = _ + _" 0 "output" "number"
"_ = _ + _" 1 "input" "number"
"_ = _ + _" 2 "input" "number"
"_ = sum(_)" 0 "output" "number"
"_ = sum(_)" 1 "aggregate" "number"
"row _" 0 "output" "number"
"_ < _" 0 "input" "number"
"_ < _" 1 "input" "number"
"_ <- _" 0 "input" "number"
"_ <- _" 1 "input" "number"
"_ <<- _" 0 "input" "text"
"_ <<- _" 1 "input" "text"
"result _ of _ split by _ is at _ to _ breaking at _" 0 "output" "number"
"result _ of _ split by _ is at _ to _ breaking at _" 1 "input" "text"
"result _ of _ split by _ is at _ to _ breaking at _" 2 "input" "text"
"result _ of _ split by _ is at _ to _ breaking at _" 3 "output" "number"
"result _ of _ split by _ is at _ to _ breaking at _" 4 "output" "number"
"result _ of _ split by _ is at _ to _ breaking at _" 5 "output" "number"
"result _ of _ searched by _ is at _ to _" 0 "output" "number"
"result _ of _ searched by _ is at _ to _" 1 "input" "text"
"result _ of _ searched by _ is at _ to _" 2 "input" "text"
"result _ of _ searched by _ is at _ to _" 3 "output" "number"
"result _ of _ searched by _ is at _ to _" 4 "output" "number"
"capture _ of result _ of _ searched by _ is at _ to _" 0 "output" "number"
"capture _ of result _ of _ searched by _ is at _ to _" 1 "output" "number"
"capture _ of result _ of _ searched by _ is at _ to _" 2 "input" "text"
"capture _ of result _ of _ searched by _ is at _ to _" 3 "input" "text"
"capture _ of result _ of _ searched by _ is at _ to _" 4 "output" "number"
"capture _ of result _ of _ searched by _ is at _ to _" 5 "output" "number"
"_ with _ replaced by _ is _" 0 "input" "text"
"_ with _ replaced by _ is _" 1 "input" "text"
"_ with _ replaced by _ is _" 2 "input" "text"
"_ with _ replaced by _ is _" 3 "output" "text"
"the text at _ to _ in _ is _" 0 "input" "number"
"the text at _ to _ in _ is _" 0 "input" "number"
"the text at _ to _ in _ is _" 0 "input" "text"
"the text at _ to _ in _ is _" 0 "output" "text"
"_ has length _" 0 "input" "text"
"_ has length _" 1 "output" "number"
"_ is number _" 0 "input" "text"
"_ is number _" 1 "output" "number"
"_ is id _" 0 "input" "text"
"_ is id _" 1 "output" "id"
"_ != _" 0 "input" "number"
"_ != _" 1 "input" "number"
"count _" 0 "aggregate" "number"
"_ = get bit _ of _" 0 "output" "number"
"_ = get bit _ of _" 1 "input" "number"
"_ = get bit _ of _" 2 "input" "id"
"_ = set bit _ of _" 0 "output" "id"
"_ = set bit _ of _" 1 "input" "number"
"_ = set bit _ of _" 2 "input" "id"

node ?n:number clause ?c:number binding ?b:number is at ?ba:number ?bz:number
+
clause ?c of node ?n is at ?ca ?cz
child "clause body" ?cba ?cbz of "clause" ?ca ?cz has text _
child "binding" ?ba ?bz of "clause body" ?cba ?cbz has text _
row ?b over ?ba ?bz

node ?n:number clause ?c:number binding ?b:number binds ?v:text
+
node ?n clause ?c binding ?b is at ?ba ?bz
child "variable" ?va ?vz of "binding" ?ba ?bz has text ?v

node ?n:number clause ?c:number depends on ?kind:text ?v:text
+
clause ?c of node ?n is primitive
clause ?c of node ?n is at ?ca ?cz
clause ?va ?vz is named ?name
node ?n clause ?c binding ?b binds ?v
primitive ?name field ?b is a ?kind _

node ?n:number clause ?c:number cannot be run on subtree ?t:id
+
node ?n has subtree ?t
node ?n clause ?c depends on "input" ?v
! node ?n subtree ?t binds ?v
+
node ?n has subtree ?t
node ?n clause ?c depends on "aggregate" ?v
! node ?n subtree ?t binds ?v
+
node ?n has subtree ?t
node ?n clause ?c depends on "aggregate" ?v
node ?n subtree ?t does not finish ?v

