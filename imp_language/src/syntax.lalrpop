use std::str::FromStr;
use super::{Name, Expression, Value};

use super::Name::*;
use Expression::*;

grammar;

pub Expression0: Expression = {
    <n:Name> "->" <e: Expression0> => AbstractFirst(box n, box e),
    // <n:Name> "=>" <e: Expression0> => AbstractHigher(vec![n], e),
    Expression1,
}

pub Expression1: Expression = {
    <e1:Expression2> "=" <e2:Expression2> => Expression::apply_higher(Reference(Equals), vec![e1, e2]),
    Expression2,
}

pub Expression2: Expression = {
    <e1:Expression2> "|" <e2:Expression3> => Expression::apply_higher(Reference(Union), vec![e1, e2]),
    <e1:Expression2> "&" <e2:Expression3> => Expression::apply_higher(Reference(Intersect), vec![e1, e2]),
    Expression3,
}

pub Expression3: Expression = {
    "!" <e:Expression3> => ApplyHigher(box Reference(Negate), box e),
    Expression4,
}

pub Expression4: Expression = {
    "nothing" => Nothing,
    "something" => Something,
    "everything" => Everything,
    "_" => Everything,
    <l:Literal> => Literal(l),
    "(" <es: Comma<Expression0>> ")" => {
        let mut es = es;
        if es.len() > 0 {
            let e = es.remove(0);
            es.into_iter().fold(e, |e1, e2| Expression::apply_higher(Reference(Tuple), vec![e1, e2]))
        } else {
            Something
        }
    },
    <f:Expression4> "[" <args: Comma<Expression0>> "]" => Expression::apply_first(f, args),
    <f:Expression4> "{" <args: Comma<Expression0>> "}" => Expression::apply_higher(f, args),
    <n: Name> => Reference(n),
    
    ! => SyntaxError(format!("{:?}", <>)),
}

pub Name: Name = {
    <n:r"[[:alpha:]]([[:alnum:]]|[-_\?!])*"> => super::Name::Name{name: n.to_owned(), scope: None},
}

pub Literal: Value = {
    <s:r#""(\.|[^"])*""#> => Value::String(s[1..(s.len()-1)].to_owned()),
    <n:r"[0-9]+"> => Value::Number(i64::from_str(n).unwrap()),
}

Comma<Rule>: Vec<Rule> =
    <rules: (<Rule> ",")*> <last: Rule?> => {
        let mut rules = rules;
        rules.extend(last);
        rules
    };
