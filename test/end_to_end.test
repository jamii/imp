42
---
type: number
value: 42

3.14 , 4.5
---
type: number , number
value: 3.14 , 4.5

"foo"
---
type: text
value: "foo"

// TODO print escapes properly
"foo\"bar"
---
type: text
value: "foo"bar"

// TODO expand boxes
[1]
---
type: [(type of expr #0 with scope ())]
value: [(value of expr #0 with scope ())]

a: 1;
a
---
type: number
value: 1

// TODO expand boxes
a: [1];
a
---
type: [(type of expr #0 with scope ())]
value: [(value of expr #0 with scope ())]

foo: ?a a;
foo 1
---
type: number
value: 1

foo: ?a ?b a,b;
foo 1 2
---
type: number , number
value: 1 , 2

1 , 2 , 3 , 4 4
---
type: number , number , number
value: 1 , 2 , 3

(1 , 2 , 3 , 4) 4
---
type: number , number , number
value: none

1 , 2 , 3 , 4 1
---
type: number , number , number
value: none

(1 , 2 , 3 , 4) 1
---
type: number , number , number
value: 2 , 3 , 4

1 , 2 | 3 , 4
---
type: number , number
value: 1 , 2 | 3 , 4

1 , (2 | 3) , 4
---
type: number , number , number
value: 1 , 2 , 4 | 1 , 3 , 4

a:
 , 1
 , 2
 , 3;
a
---
type: number , number , number
value: 1 , 2 , 3

a:
  | 1, 2, 3
  | 4, 5, 6;
a
---
type: number , number , number
value: 1 , 2 , 3 | 4 , 5 , 6

// TODO this is a result of the hacky way that preceding operators are handled
a: |,&|,& 1;
a
---
type: number
value: 1

1 + 2 * 3
---
Parse error: Ambiguous precedence for `+` vs `*`

(1 + 2) * 3
---
type: number
value: 9

3 * 2 + 1
---
Parse error: Ambiguous precedence for `*` vs `+`

3 * (2 + 1)
---
type: number
value: 9

// parses as 1 , (2 3)
1 , 2 3
---
type: number
value: none

// parses as 1 , (2 2)
1 , 2 2
---
type: number
value: 1

a & b | c
---
Parse error: Ambiguous precedence for `&` vs `|`

a * b / c
---
Parse error: Ambiguous precedence for `*` vs `/`

1 + 2 | 5
---
type: number
value: 3 | 5

?a ?[b] (a | b) , c
---
Desugar error: Name not in scope: c

1 , "foo" | 2
---
Analyze error: Mismatched arities: 2 vs 1

1 1 !
---
type: maybe
value: none

1 2 !
---
type: maybe
value: some

foo: 1, 1, 1;
foo 1 1 1 !
---
type: maybe
value: none

foo: 1, 1, 1;
foo 2 1 1 !
---
type: maybe
value: some

when some 1,2
---
type: number , number
value: 1 , 2

when none 1,2
---
type: number , number
value: none

a: 1 , "foo";
a , a
---
type: number , text , number , text
value: 1 , "foo" , 1 , "foo"

foo: ?a ?b a=b;
foo 1 1
---
type: maybe
value: some

foo: ?a ?b a=b;
foo 1 2
---
type: maybe
value: none

foo: ?a [?b a,b];
foo 1 ?[bar] bar 2
---
type: number , number
value: 1 , 2

foo1: ?a [?b a,b];
foo2: ?a [?b a,b];
bar: foo1 1 | foo2 2;
bar ?[f] f 3
---
Analyze error: TODO type unions are not implemented yet: [(type of expr #3 with scope (number))] | [(type of expr #10 with scope ([(type of expr #5 with scope ())] , number))]

foo: 1 , 1 | 2 , 2;
foo foo
---
type: maybe
value: some

foo: ?a ?b a,b;
foo foo
---
Analyze error: Cannot apply two maybe-infinite sets: (type of expr #4 with scope ()) applied to (type of expr #4 with scope ())

foo: ?a ?b a,b;
foo = 1
---
Analyze error: Cannot equal one or more maybe-infinite sets: (type of expr #4 with scope ()) = number

foo: ?a ?b a,b;
(foo | foo) 1 2
---
type: number , number
value: 1 , 2

when (?a none) 1
---
Analyze error: The condition of `when` must have type `maybe`, found (type of expr #1 with scope ())

foo: ?a ?b a=b;
(foo , 1 , 2) 0 0 1 2
---
type: maybe
value: some

foo: ?a ?b a=b;
(foo , 1 , 2) 0 1 1 2
---
type: maybe
value: none

3: 4; 5
---
Parse error: Found `:` without preceding name

fix 1 ?[prev] if (prev 10) 10 else prev + 1
---
type: number
value: 10

fix 1 ?[prev] if (prev 5) prev else prev | prev ?a a+1
---
type: number
value: 1 | 2 | 3 | 4 | 5

range:
  ?lo ?hi
    fix lo ?[prev]
      if (prev hi)
        prev
      else
        prev | prev ?a a+1;
range 2 5
---
type: number
value: 2 | 3 | 4 | 5

edge: 1 , 2 | 2 , 3 | 3 , 4 | 3 , 1;
fix edge ?[reach] reach | reach ?a ?b a , edge b
---
type: number , number
value: 1 , 1 | 1 , 2 | 1 , 3 | 1 , 4 | 2 , 1 | 2 , 2 | 2 , 3 | 2 , 4 | 3 , 1 | 3 , 2 | 3 , 3 | 3 , 4

edge: 1 , 2 | 2 , 3 | 3 , 4 | 3 , 1;
node: edge ?a ?b a | b;
node ?a a , fix a ?[reach] reach | reach ?a edge a
---
type: number , number
value: 1 , 1 | 1 , 2 | 1 , 3 | 1 , 4 | 2 , 1 | 2 , 2 | 2 , 3 | 2 , 4 | 3 , 1 | 3 , 2 | 3 , 3 | 3 , 4 | 4 , 4

closure:
  ?[edge]
    fix edge ?[reach]
      reach | reach ?a ?b a , edge b;
closure [1 , 2 | 2 , 3 | 3 , 4 | 3 , 1]
---
type: number , number
value: 1 , 1 | 1 , 2 | 1 , 3 | 1 , 4 | 2 , 1 | 2 , 2 | 2 , 3 | 2 , 4 | 3 , 1 | 3 , 2 | 3 , 3 | 3 , 4

fix 1 2
---
Analyze error: The `next` argument for fix must be able to be applied to it's own result, found number

fix 1 ?[prev] prev,2
---
Analyze error: The `next` argument for fix must have constant arity, changed from 1 to 2

range (0 - 3) 3
---
type: number
value: -3 | -2 | -1 | 0 | 1 | 2 | 3

range 3 2
---
type: number
value: none

range 0.5 1.5
---
Native error: Inputs to `range` must be whole numbers, found `range 0.5 1.5`

enumerate ("c" , 0 | "a" , 0 | "b" , 1 | "b" , 0.1)
---
type: number , text , number
value: 1 , "a" , 0 | 2 , "b" , 0.1 | 3 , "b" , 1 | 4 , "c" , 0

enumerate ("c" , 0 | "a" , 0 | "b" , 1 | "b" , 0.1) (range 2 3)
---
type: text , number
value: "b" , 0.1 | "b" , 1

reduce (3 | 4 | 5) 0 ?[prev] ?[i] prev + i
---
type: number
value: 12

// TODO
// reduce (none :: number) 0 ?[prev] ?[i] prev + i
reduce ((1 , 2) 3) 0 ?[prev] ?[i] prev + i
---
type: number
value: 0

reduce (3 | 4 | 5) 0 ?a ?b a + b
---
Analyze error: Intersection of number and [(type of expr #13 with scope ())] is empty

// testing specialization caching
f: ?i i+1;
(f 1) , (f 2) , (f 3 4) , (f 5 6)
---
type: number , number
value: 2 , 3

collatz:
  ?n
    fix n ?[n]
      if (n = 1)
        1
      else
        if ((n % 2) 0)
          n / 2
        else
          (3 * n) + 1;
collatz 42
---
type: number
value: 1

foo: 1 , "a" | 2 , "b";
~foo
---
type: text , number
value: "a" , 1 | "b" , 2

(1 | 2 | 3) . ?a a+1
---
type: number , number
value: 1 , 2 | 2 , 3 | 3 , 4

(1 | 2 | 3) . (?a a>1)
---
type: number
value: 2 | 3

(1 | 2 | 3) (?a a-1) . (?a a>1)
---
type: number
value: 2

edits: range 0 8;
root: 0;
parent:
  | 1 , 0
  | 2 , 0
  | 3 , 1
  | 4 , 1
  | 5 , 2
  | 6 , 5
  | 7 , 5
  | 8 , 5;
character:
  | 0 , "a"
  | 1 , "b"
  | 2 , "e"
  | 3 , "c"
  | 4 , "d"
  | 5 , "f"
  | 6 , "g"
  | 7 , "h"
  | 8 , "i";
// TODO need a version of reduce that doesn't return output on empty input
max:
  ?[things]
    when (things!!)
      reduce things none ?[prev] ?[i] if (prev > i) prev else i;
rightmost_child:
  edits . ?edit [edit (~parent)] max;
rightmost_leaf:
  fix
    none
    ?[rightmost_leaf]
      edits . ?edit
        // TODO swapping child and leaf shouldn't matter, but causes test to spin forever
        [edit | edit rightmost_child rightmost_leaf] max;
prev_sibling:
  edits . ?edit
    [edit parent (parent~) . ?sibling edit > sibling] max;
prev:
  edits . ?edit
    if (edit prev_sibling !!)
      edit prev_sibling rightmost_leaf
    else
      edit parent;
position:
  fix none ?[position]
    | root, 0
    | position ?edit ?pos edit (~prev) , pos + 1;
edits ?edit
  (edit position) , edit , (edit character)
---
type: number , number , text
value: 0 , 0 , "a" | 1 , 1 , "b" | 2 , 3 , "c" | 3 , 4 , "d" | 4 , 2 , "e" | 5 , 5 , "f" | 6 , 6 , "g" | 7 , 7 , "h" | 8 , 8 , "i"

fix none ?[prev] 1
---
type: number
value: 1

fix none ?[prev] none
---
type: none
value: none