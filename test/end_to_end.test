42
---
type: number
value: 42

3.14
---
type: number
value: 3.14

"foo"
---
type: text
value: "foo"

// TODO print escapes properly
"foo\"bar"
---
type: text
value: "foo"bar"

// TODO expand boxes
[1]
---
type: [number]
value: [expr #0 with scope]

let a = 1 in
a
---
type: number
value: 1

// TODO expand boxes
let a = [1] in
a
---
type: [number]
value: [expr #0 with scope]

let foo = \ a -> a in
foo 1
---
type: number
value: 1

let foo = \ a b -> a . b in
foo 1 2
---
type: number . number
value: 1 . 2

1 (1 . 2 . 3 . 4)
---
type: number . number . number
value: 2 . 3 . 4

1 . 2 | 3 . 4
---
type: number . number
value: 1 . 2 | 3 . 4

1 . (2 | 3) . 4
---
type: number . number . number
value: 1 . 2 . 4 | 1 . 3 . 4

1 + 2 * 3
---
type: number
value: 7

(1 + 2) * 3
---
type: number
value: 9

3 * 2 + 1
---
type: number
value: 7

3 * (2 + 1)
---
type: number
value: 9

let foo = "bar" . [1] in
foo:bar
---
type: number
value: 1

a & b | c
---
Parse error: Ambiguous precedence for Token{ .Intersect = void } vs Token{ .Union = void }

a * b / c
---
Parse error: Ambiguous precedence for Token{ .Multiply = void } vs Token{ .Divide = void }

a | b c
---
Parse error: Ambiguous precedence for Token{ .Union = void } vs Token{ .Apply = void }

a + b | c
---
Parse error: Ambiguous precedence for Token{ .Add = void } vs Token{ .Union = void }

\ a [b] -> a | b . c
---
Desugar error: Name not in scope: c

1 . "foo" | 2
---
Analyze error: Mismatched arities: 2 vs 1

!(1 1)
---
type: maybe
value: none

!(1 2)
---
type: maybe
value: some

when some then 1 . 2
---
type: number . number
value: 1 . 2

when none then 1 . 2
---
type: number . number
value: none

let a = 1 . "foo" in
a . a
---
type: number . text . number . text
value: 1 . "foo" . 1 . "foo"

// TODO
let foo = \ a b -> a = b in
foo 1 1
---
type: maybe
value: some

// TODO
let foo = \ a b -> a = b in
foo 1 2
---
type: maybe
value: none

let foo = \ a -> [\ b -> a . b] in
foo 1 \ [bar] ->
bar 2
---
type: number . number
value: 1 . 2

let foo1 = \ a -> [\ b -> a . b] in
let foo2 = \ a -> [\ b -> a . b] in
let bar = (foo1 1) | (foo2 2) in
bar \ [f] -> f 3
---
Analyze error: TODO type unions are not implemented yet (in unionScalar ScalarType{ .Box = SetType{ .Lazy = LazySetType{ .expr = Expr{ ... }, .scope = ScalarType@1de4690 } } } ScalarType{ .Box = SetType{ .Lazy = LazySetType{ .expr = Expr{ ... }, .scope = ScalarType@1de4c30 } } })

let foo = 1 . 1 | 2 . 2 in
foo foo
---
type: maybe
value: some

let foo = \ a b -> a . b in
foo foo
---
Analyze error: Cannot apply two maybe-infinite sets: SetType{ .Lazy = LazySetType{ .expr = Expr{ .Abstract = Expr{ ... } }, .scope = ScalarType@0 } } vs SetType{ .Lazy = LazySetType{ .expr = Expr{ .Abstract = Expr{ ... } }, .scope = ScalarType@0 } }

let foo = \ a b -> a . b in
foo = 1
---
Analyze error: Cannot equal one or more maybe-infinite sets

let foo = \ a b -> a . b in
(foo | foo) 1 2
---
type: number . number
value: 1 . 2

when (\ a -> none) then 1
---
Analyze error: The condition of `when` must have type `maybe`, found SetType{ .Lazy = LazySetType{ .expr = Expr{ .Abstract = Expr{ ... } }, .scope = ScalarType@0 } }

let foo = \ a b -> a = b in
(foo . 1 . 2) 0 0 1 2
---
type: maybe
value: some

let foo = \ a b -> a = b in
(foo . 1 . 2) 0 1 1 2
---
type: maybe
value: none